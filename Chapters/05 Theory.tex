\chapter{\label{theory}Theory}
\thispagestyle{fancy}


\section{OSS/BSS}

\cn{
Differentiate OSS and BSS. Where NetBox will be the core OSS and everything
connecting to it is the BSS.
}

\cn{includes inventory management}

\section{Secure credential storage}

\cn{Need for credentials in configuration}

\cn{Refer to security theory, least privileges, etc.}


\section{Network Management Systems}

% Mostly propieritary solutions
% - Cisco
% - Juniper
% - etc.

\section{Configuration Methods}

\subsection{CLI Configuration}

Probably the most common method of configuring devices is through its \acrlong{CLI}. 
Most modern networking hardware supports access to the \acrshort{CLI} through SSH,
but in cases where networking may not be available, the same interface is often also
presented in the form of a serial connection, through a dedicated port on the device.

As there is no standardization for the \acrshort{CLI} across vendors, it makes it a
difficult target for automation in a vendor agnostic space. On the other hand it
is also usually the most complete interface in terms of features for the device
you are configuring, as most vendors recognise it as the primary interface for configuration\cite{noauthor_configuration_nodate}.

There are projects such as NAPALM (Network Automation and Programmability Abstraction Layer with Multivendor support)\cite{noauthor_napalm_nodate}
which aim to solve the problem of providing a similar interface to multiple vendors,
but the functionality of such projects is severely limited in terms of interfaces provided
for configuration across vendors.

Since the \acrshort{CLI} is a text based interface, it makes it hard to validate the configuration
before deployment. Especially since the order of configuration statements often matters
(e.g. you cannot assign a VLAN before creating it), it makes it hard to stitch together
multiple templates without having an engine understand the whole configuration before sending
it off to the device.

\subsection{SNMP}

The Simple Network Management Protocol (SNMP)\cite{fedor_simple_1990} is a protocol which was originally
designed in the 1980s by a group of collaborators which sought to create a protocol which would
allow large scale-deployment of the internet.
As the name implies, it is quite a simple protocol based on a few key operations:
GetRequest, SetRequest, GetNextRequest, GetBulkRequest and some more.

In practice it works with vendor supplied ,,management information base'' (MIB) files, which identify a collection of
of object identifiers (OIDs) with a name, description and data-type. 
Along the vendor specific MIBs, there are also some standard collections,
which try to define generic information which can be queried.
So for example the OID ,,1.3.6.1.2.1.1.1'' corresponds to ,,iso.org.dod.internet.mgmt.mib.system.sysDescr''
which represents a textual description of the device which is queried.

SNMP is still largely used today for monitoring, as it is a (as the name implies) simple and light protocol
which usually doesn't generate a lot of overhead. There are some shortcomings though when it comes to
structured configuration data, especially with write/set operations. Altough data types can now be verified
using the MIB files, a configuration section as a whole still cannot be verified before sending it to a device,
as dependencies between configuration nodes cannot be specified in the MIB format. Also handling data
in lists is complex, as when one wants to edit a specific node, the whole list first has to be searched
with get requests in order to identify the correct offset which is to be modified.

\subsection{NETCONF}

NETCONF is a protocol developed and stadardized in 2006 \ci{cite} by \acrshort{IETF}.
While it is comparable to SNMP, there are key differences:
It is based on \acrfull{RPC}s encoded with XML.
This allows the protocol to send complex but structured data, providing broad flexibility
when interacting with configuration data. 
This becomes apparrent when for example configuring an interface, where the actual configuration
can be represented with nested data structures.
Notable is also, that the ,,reference'' configuration method, i.e. the CLI, also often has some form
of nesting in its configuration, which can therefore be represented more clearly with NETCONF.

The \acrshort{RPC}s are comprised of some key operations: ,,<get-config>'' which allows one to read
the configuration of a device, ,,<edit-config>'' which allows manipulation of the config, ,,<get>''
which allows reading of operational data for monitoring or statistics, and others which are not
relevant for this thesis. 
The important detail to these operations, is that all of them allow to specify what exactly shall
be retreived or written within a single \acrshort{RPC}. Combined with the fact that a structured
markup language is used (XML), it becomes trivial to combine and manipulate fragments of configuration.

While there are tools to validate XML against a given schema without sending the configuration to the device,
notably \acrfull{XSD}, it is still somewhat limited in functionality, 
which is why NETCONF got extended with the YANG language explained below.

\subsection{NETCONF/YANG}

YANG is not a configuration protocol or format in itself.
It is described as ,,a data modeling language used to model configuration and
state data manipulated by the Network Configuration Protocol (NETCONF)''\ci{cite rfc6020}.
It aims to solve some limitations of the XML validation language XSD and further make it
easier to define the data models for engineers.

\cn{Perhaps compare a snipped of XSD and YANG}

Similar to SNMP, there are some ,,standard'' models defined by \acrshort{IETF}, IANA, IEEE
and a collective called OpenConfig. But even if a device might not support those standard
models completely, there are mechanism defined in NETCONF/YANG which allow an engineer
to discover which models a device supports and also download these models directly from the
device itself. This brings a huge benefit in terms of discoverability in what is possible
to configure on a given device, contrary to SNMP, where the engineer is reliant on
the vendor to supply the correct MIB files.

While not every vendor supports NETCONF, the number in the enterprise space is large by
having support from Juniper, Cisco, Extreme Networks, Nokia, Ruckus and more.
With this widespread support, there is also diverse tooling available to aide in development
with NETCONF and YANG:

\paragraph{CESNET libraries and tools} CESNET, an association of universities of the Czech Republic,
offers a suite of libraries to develop systems with NETCONF and YANG.
The Sysrepo\ci{cite} library, allows application developers to add YANG based configuration models to their
applications, which can then be combined with the Netopeer2\ci{cite} project to automatically integrate NETCONF
support. While not directly useful for writing a NETCONF client, their libyang\ci{cite} library offers
tooling for interpreting and validating YANG models. This library also offers functionality when
working with instance data (e.g. a configuration snippet) in order to validate or manipulate this data.

\paragraph{Cisco YANG Suite} \ci{discoverability visibility etc.}

\paragraph{ncclient} \ci{python stuff}

\cn{mention RESTCONF}

\subsection{HTTP APIs}

\cn{Completely vendor specific}
\cn{Often not available at all}

\section{User Interface for Engineers}

\cn{Existing user interfaces}

\cn{Gathering information from documentation}

\cn{Gathering information from Yang Models}

\section{Case Study - Init7 (Schweiz) AG}

\cn{Current state: Not a lot of automation}

\cn{If configuration from OSS - forces correct documentation -> documentation implies configuration}


